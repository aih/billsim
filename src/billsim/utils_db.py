#!/usr/bin/env python3

import sys
import logging
from typing import Optional
from sqlalchemy.orm import Session
from billsim.utils import getBillLength, getBillnumberversionParts
from billsim.database import SessionLocal
from billsim import pymodels, constants

logger = logging.getLogger(__name__)
logger.addHandler(logging.StreamHandler(sys.stdout))
logging.basicConfig(level='INFO')

# TODO: take the Section object (which consists of the from Section Meta and a list of similar sections)
# returned in bill_similarity.getBillToBill()
# Save a) the from section and each similar section, in the SectionItem table if it does not exist,
# and b) the similarity score between the sections in the SectionToSection table


def save_bill(
    bill: pymodels.Bill,
    db: Session = SessionLocal()) -> Optional[pymodels.Bill]:
    """
    Save a bill to the database.
    """
    with db as session:
        session.add(bill)
        session.flush()
        session.commit()
        logger.info(
            f'Flush and Commit to save bill {bill.billnumber} {bill.version}')
        bill_saved = session.query(pymodels.Bill).filter(
            pymodels.Bill.billnumber == bill.billnumber,
            pymodels.Bill.version == bill.version).first()
        if bill_saved is None:
            logger.error(
                f'Bill not saved to db: {bill.billnumber} {bill.version}')
            return None
        else:
            return bill_saved


def get_bill_by_billnumber_version(
    billnumber_version: str, db: Session = SessionLocal()
) -> Optional[pymodels.Bill]:
    billnumber_version_dict = getBillnumberversionParts(billnumber_version)
    logger.debug('billnumber_version_dict: {}'.format(
        str(billnumber_version_dict)))
    bill = db.query(pymodels.Bill).filter(
        pymodels.Bill.billnumber == billnumber_version_dict.get('billnumber'),
        pymodels.Bill.version == billnumber_version_dict.get(
            'version')).first()
    if bill is None:
        return None
    return bill


def get_or_create_sectionitem(section_meta: pymodels.SectionMeta,
                              db: Session = SessionLocal()):
    logger.info("section_meta: {}".format(section_meta))
    if section_meta.billnumber_version is None:
        return None
    bill = get_bill_by_billnumber_version(section_meta.billnumber_version)
    if bill is None:
        billnumber_version_dict = getBillnumberversionParts(
            section_meta.billnumber_version)
        billnumber = str(billnumber_version_dict.get('billnumber'))
        version = str(billnumber_version_dict.get('version'))
        bill = save_bill(pymodels.Bill(billnumber=billnumber, version=version),
                         db)
    if bill is None:
        return None
    sectionItem = db.query(pymodels.SectionItem).filter(
        pymodels.SectionItem.bill_id == bill.id,
        pymodels.SectionItem.section_id == section_meta.section_id).first()
    if sectionItem is None:
        if section_meta.label is None or section_meta.header is None or section_meta.length is None:
            logger.warning(
                'Section meta is missing label, header or length: {section_meta}'
            )
        sectionItem = pymodels.SectionItem(bill_id=bill.id,
                                           section_id=section_meta.section_id,
                                           label=section_meta.label,
                                           header=section_meta.header,
                                           length=section_meta.length)
        db.add(sectionItem)
        db.flush()
        db.commit()
        # NOTE: sectionItem should now have an autogenerated id
        return sectionItem
    else:
        logger.debug('SectionItem already exists')
        return sectionItem


def save_section_to_section(section_meta: pymodels.SectionMeta,
                            similar_section: pymodels.SimilarSection,
                            db: Session = SessionLocal()):
    sectionItem = get_or_create_sectionitem(section_meta, db)
    if sectionItem is None:
        # TODO: raise exception?
        return None
    similar_section_item = get_or_create_sectionitem(
        pymodels.SectionMeta(**dict(similar_section)), db)
    if similar_section_item is None:
        # TODO: raise exception?
        return None
    section_to_section = db.query(pymodels.SectionToSection).filter(
        pymodels.SectionToSection.id == sectionItem.id,
        pymodels.SectionToSection.id_to == similar_section_item.id).first()
    if section_to_section is None:
        section_to_section = pymodels.SectionToSection(
            id=sectionItem.id,
            id_to=similar_section_item.id,
            score_es=similar_section.score_es,
            score=similar_section.score,
            score_to=similar_section.score_to)
        db.add(section_to_section)
    else:
        logger.info('SectionToSection already exists')
        # Update the scores that we have
        if similar_section.score_es:
            logger.info('SectionToSection adding/updating score_es')
            setattr(section_to_section, 'score_es', similar_section.score_es)
        if similar_section.score:
            logger.info('SectionToSection adding/updating score')
            setattr(section_to_section, 'score', similar_section.score)
        if similar_section.score_to:
            logger.info('SectionToSection adding/updating score_to')
            setattr(section_to_section, 'score_to', similar_section.score_to)
    db.flush()
    db.commit()
    return section_to_section


def save_section(
    section: pymodels.Section, db: Session = SessionLocal()) -> Optional[int]:
    """
   Get the sectionMeta from the section
   check if a SectionItem row exists for this sectionMeta
   if not, create one
   Then do the same for each similar_section
   Then save the section to section between the from and to
   """
    section_meta = pymodels.SectionMeta(**dict(section))
    section_item = get_or_create_sectionitem(section_meta)
    if not section_item:
        raise Exception('Could not create or get sectionItem from section')
    for similar_section in section.similar_sections:
        save_section_to_section(section_meta, similar_section, db)


def save_bill_to_bill(bill_to_bill_model: pymodels.BillToBillModel,
                      db: Session = SessionLocal()):
    """
    Save bill to bill join to the database.
    """
    bill = get_bill_by_billnumber_version(bill_to_bill_model.billnumber_version)
    if bill is None:
        logger.warning('No bill found in db for {}'.format(
            bill_to_bill_model.billnumber_version))
        try:
            billnumber_version_dict = getBillnumberversionParts(
                bill_to_bill_model.billnumber_version)
            billnumber = str(billnumber_version_dict.get('billnumber'))
            version = str(billnumber_version_dict.get('version'))
        except:
            logger.error(
                'Billnumber version not of the correct form: {}'.format(
                    bill_to_bill_model.billnumber_version))
            return

        bill = save_bill(
            pymodels.Bill(billnumber=billnumber,
                          version=version,
                          length=bill_to_bill_model.length))

    bill_to = get_bill_by_billnumber_version(
        bill_to_bill_model.billnumber_version_to)
    if bill_to is None:
        err_msg = 'No bill found in db for {}'.format(
            bill_to_bill_model.billnumber_version_to)
        logger.warning(err_msg)
    else:
        try:
            billnumber_version_to_dict = getBillnumberversionParts(
                bill_to_bill_model.billnumber_version_to)
        except:
            logger.error(
                'Billnumber version (to bill) not of the correct form: {}'.
                format(bill_to_bill_model.billnumber_version_to))
            return
        billnumber_to = str(billnumber_version_to_dict.get('billnumber'))
        version_to = str(billnumber_version_to_dict.get('version'))
        length_to = getBillLength(bill_to_bill_model.billnumber_version_to)
        bill_to = save_bill(
            pymodels.Bill(billnumber=billnumber_to,
                          version=version_to,
                          length=length_to))
    if bill is None or bill_to is None:
        raise Exception(
            'Could not create bill item for one or both of: {0}, {1}.'.format(
                bill_to_bill_model.billnumber_version,
                bill_to_bill_model.billnumber_version_to))
    #sections = json.dumps(bill_to_bill_model.sections)
    logger.info('Saving bill to bill join: {0} & {1}'.format(
        bill.id, bill_to.id))
    bill_to_bill = pymodels.BillToBillLite(
        bill_id=bill.id,
        bill_to_id=bill_to.id,
        score_es=bill_to_bill_model.score_es,
        score=bill_to_bill_model.score,
        score_to=bill_to_bill_model.score_to,
        reasons=bill_to_bill_model.reasons,
        identified_by=bill_to_bill_model.identified_by,
        sections_num=bill_to_bill_model.sections_num,
        sections_matched=bill_to_bill_model.sections_match)
    with db as session:
        session.add(bill_to_bill)
        db.flush()
        session.commit()


def save_bill_to_bill_sections(bill_to_bill_model: pymodels.BillToBillModel,
                               db: Session = SessionLocal()):
    """
    For each bill to bill, save the 'sections' object, which includes the sections of the 'from'
    bill in order, along with the top similar section of the 'to' bill.
    """
    sections = bill_to_bill_model.sections
    if sections is None:
        return None
    for section in sections:
        save_section(section, db)